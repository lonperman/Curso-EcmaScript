# ‚öô EcmaScript 6
## 1Ô∏è‚É£ Scope (Alcance de una variable)
   > Las formas de definir una variable en JavaScript como lo son var, let y const, tienen presente un respectivo alcance por lo cual se debe tener presente al momento de ser definidas en el desarrollo de un proyecto.


```
const fruits = () => {
    if(true){
        var fruit1 = 'Apple'; // function scope
        let fruit2 = 'Kiwi'; // block scope
        const fruit3 = 'Banana'; // block scope
    }

    console.log(fruit1); // La variable var se imprime
    console.log(fruit2); // variable let no se imprime por su respectivo scope
    console.log(fruit3) //variable const no se imprime por su respectivo scope
}

üë®‚Äçüíª fruits()

‚úÖ ---> Result: 1Ô∏è‚É£ Console.log(fruit1) => Apple
‚ùå ---> Result: 2Ô∏è‚É£ Console.log(fruit2) => fruit2 is not defined.
‚ùå ---> Result: 3Ô∏è‚É£ Console.log(fruit3) => fruit3 is not defined.

```

## 2Ô∏è‚É£ Arrow Functions (Funciones Flecha)
> En la version de ecmaScript 6 contamos con las funciones flecha en donde se agrega una nueva forma de definir una funcion ademas de la forma convencional de como se definen dentro del desarrollo de un proyecto.

```
// Forma normal de definir una funcion.

function square(num){
    return num*num;
}

üë®‚Äçüíª ---> console.log(square(3));
‚úÖ ---> Result: 9
```

```
// Forma de definir una funcion como arrow-function.

const square = (num) => {
    return num*num;
}

üë®‚Äçüíª ---> console.log(square(3));
‚úÖ ---> Result: 9

// Arrow con el return implicito

const square = num => num*num;

üë®‚Äçüíª ---> console.log(square(3));
‚úÖ ---> Result: 9
```
## 3Ô∏è‚É£ Template Literals (Uso de strings y variables)
  > Los templates literals se utilizan para plasmar textos de una manera m√°s dinamica, ya que este nos permite utilizar string y variables dentro de un mismo texto o parrafo dandonos la opcion de cambiar ciertos elementos y ahorrandonos en si, el volver escribir el mismo texto y tener que cambiar ciertas palabras.

```
let hello = 'Hello';
let world = 'World';
let epicPhrase = hello + ' ' + world + '!';

// Forma normal.
üë®‚Äçüíª console.log(epicPhrase);
‚úÖ ---> Result: Hello World!

// Template Literals
let epicPhrase2 = `${hello} ${world}`;

üë®‚Äçüíª console.log(epicPhrase2)
‚úÖ ---> Result: Hello World
```

> Los temple literals nos pueden ahorrar el tener que estar indicandole donde realizar un salto de linea.

```
// Multi-line strings
let lorem = 'esto es un string \n' + 'esto es otra linea';

// Temple-literal
let lorem2 = `Esta es una frase epica
 la continuacion de esa frase epica.`;

üë®‚Äçüíª console.log(lorem);
üë®‚Äçüíª console.log(lorem2)

‚úÖ ---> esto es un string 
        esto es otra linea // 1Ô∏è‚É£ Primer console

‚úÖ ---> Esta es una frase epica
        la continuacion de esa frase epica. // 2Ô∏è‚É£ Segundo console.
```

## 4Ô∏è‚É£ Default-params. (Definicion de parametros con valor por defecto)
> Aveces cuando estamos desarrollando un  programa definimos cierta cantidad de parametros los cuales debemos enviarle a una funcion al momento de querer operarla, pero en ocaciones otro desarrollador puede pasar por desapercibido alguno de los argumentos, y esto podria causar que al momento de ejecurtar la funcion, esta arroje un error, pero si utilizamos ciertos valores por defecto en la definicion en nuestras variables podemos ahorranos complicaciones.

```
// Forma normal de definir variables por defecto.

function newUser(name, age, country){
    var name = name || 'Manuel';
    var age = age || 25;
    var country = country || 'CO';
    console.log(name, age, country);
}

üë®‚Äçüíª newUser(); 
‚úÖ ---> Result: Manuel 25 CO

üë®‚Äçüíª newUser('Alejo',25,'CO');
‚úÖ ---> Result: Alejo 25 CO
```

```
//Forma de definir por defecto los parametros desde su construccion.

function newAdmin(name = 'Manuel', age = 25, country = 'CL'){
    console.log(name, age, country);
}

üë®‚Äçüíª newAdmin();
‚úÖ ---> Result: Alejo 25 CO
```
## 5Ô∏è‚É£ Destructuring, Spread operator, Rest-params.(Destructurar arreglos y objetos,Propagar la informacion)

```
// Arrays destructuring

let fruits = ['Apple', 'Banana'];
let [a,b] = fruits;
üë®‚Äçüíª console.log(a, fruits[1]);
‚úÖ ---> Result: Apple Banana

// Object destructuring

let user = { username: 'Manuel', age: 24};
let { username, age } = user;
üë®‚Äçüíª console.log(username, user.age)
‚úÖ Result: Manuel 24
```
> Metodo que nos permite propagar la informacion sin tener la necesidad de sobreescribirla denuevo.
```
// Spread operator

let person = {name: 'Alejo', age: 25};
let country = 'CO'

let data = { ...person, country};
üë®‚Äçüíª console.log(data)
‚úÖ ---> Result: { name: 'Alejo', age: 25, country: 'CO' }
```

> Forma de dispersar la informacion utilizando un spreed como param, a esto se le define rest-spreed.
```
// Rest-spread

function sum(num, ...values){
    console.log(values);
    console.log(num + values[0]);
    return num + values[0];
}

üë®‚Äçüíª sum(1,1,2,3,4)
‚úÖ ---> Result: [ 1, 2, 3, 4 ] 2 => retorna: 2
```
## 6Ô∏è‚É£ Object-literals (Mejora a los objetos)
>Podemos utilizar funciones para que nos devuelvan un objeto con todos los argumentos que les enviamos.

```
function newUser(user, age, country, uId){
    return {
        user,
        age,
        country,
        uId
    }
}

üë®‚Äçüíª console.log(newUser("lonper", 25, "CO", 1))
‚úÖ ---> Result: { user: 'lonper', age: 25, country: 'CO', uId: 1 }
```

## 7Ô∏è‚É£ Promises (Algo que va a suceder o no).
> Las promesas se utilizan como los callbacks, los cuales reciben una funcion como parametro, pero en este caso una promesa nos devolvera el valor apartir de una validacion, lo cual podria ser aceptada o rechazada.

> ‚úÖresolve -> Si fue aceptada la validacion.

> ‚ùåreject -> Si fue rechazada la validacion.

```
const anotherFunction = () => {
    return new Promise((resolve,reject) => {
        if(true){
        ‚úÖ  resolve('Hey!!')
        } else {
        ‚ùå  reject('Whoooops!')
        }
    })
}
```
> El metodo üõ¨ then nos devuelve el resultado de la funcion üë®‚Äçüîß anotherFunction().
```
anotherFunction()
    .then(response => console.log(response))
    .catch(err => console.log(err));

‚úÖ ---> Result: Hey!!
```
## 8Ô∏è‚É£ Clases (Dise√±o de clases - Utilizando herencia)
> Las clases se han utilizado en distintos lenguajes que utilicen la orientacion a objetos, ya que las clases nos permiten utilizar la herencia en diferentes objetos en donde necesitemos cierto elementos instanciados dentro de la estructura de la clase.

```
//Declarando una clase

üë®‚Äçüîß class User {};

// Instanciando metodos dentro de la clase.

üë®‚Äçüîß class user {
    //metodos
    greeting(){
        return 'Hello';
    }
};

// Instanciando objetos y utilizando los metodos de la clase.

‚öì const gndx = new user();
üë®‚Äçüíª console.log(gndx.greeting());
‚úÖ ---> Result: Hello

‚öì const bebeloper = new user();
üë®‚Äçüíª console.log(bebeloper.greeting());
‚úÖ ---> Result: Hello

// Utilizando el constructor para inicializar.

üë®‚Äçüîß class user {
    // Constructor
    constructor(){
        console.log('Nuevo Usuario');
    }
    greeting(){
        return 'Hello';
    }
}

‚öì const manuel = new user();
‚úÖ ---> Result: Nuevo Usuario
```
### ‚öì This
> La palabra reservada this, nos sirve como puntero hacia una referencia, en este caso utilizamos this para hacer referencia al elemento padre que contiene la el valor del argumento.

```
// this 
üë®‚Äçüîß class user {
    constructor(name){
        this.name = name; //hace referecnia. 
    }
    //metodos
    speak(){
        return 'Hello';
    }
    greeting(){
        return `${this.speak()} ${this.name}`;
    }
}

‚öì const Alejo = new user('Alejo');
üë®‚Äçüíª console.log(Alejo.greeting());
‚úÖ ---> Result: Hello Alejo
```
### ‚öì Getters & Setters 
> Los metodos Getters & Setters nos permiten obtener el valor de una variable(Getters) y modificar el valor de las variables(Setters).

```
üë®‚Äçüîß class user {
    //constructor
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    // metodos
    speak(){
        return 'Hello';
    }
    greeting(){
        return `${this.speak()} ${this.name}}`
    }
    // Getter
    get uAge(){
        return this.age;
    }
    // Setter
    set uAge(n){
        this.age = n;
    }
}

// Instanciando un nuevo objeto
‚öì const bebeloper1 = new user('David', 15);

// Llamando al metodo Getter
üë®‚Äçüíª console.log(bebeloper1.uAge);
‚úÖ --> Result: 15

// Llamando al metodo Setter
üë®‚Äçüíª console.log(bebeloper1.uAge = 24);
‚úÖ --> Result: 24
```
### 9Ô∏è‚É£ Module (exportar & importar funciones de diferentes archivos)

> Aveces cuando se quiere obtener un codigo mas limpio y segmentado, no el famoso codigo espagueti, se utilizan modulos los cuales son archivos distintos, en donde estan definidas ciertas funciones que pueden ser requeridas para el desarrollo de un programa.

`$ module.js`

```
//Se instancia un metodo o funcion en un archivo diferente.

üë®‚Äçüîß const hello = () => {
    console.log('Hello!');
}

//Se exporta el metodo o la funcion del archivo.

üõ´ export default hello;
```

`$ 08-module.js`
```
// Se importa los elementos del otro archivos.
üõ¨ import hello from "./module.js";

// Se ejecuta el metodo importado

üë®‚Äçüíª hello();
‚úÖ ---> Result: Hello!
```

> Se debe configurar el archivo package.json para poder utilizar un modulo.

`$ package.json`
```
{
  "name": "curso-de-ecmascript",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "javascript",
    "ecmascript"
  ],
  "author": "Manuel Perdomo <lonperman@gmail.com>",
  "license": "MIT",
  "type": "module" // ‚ûï Se agrega el modulo. 
}
```

## üîü Generadores
> Los generadores son funciones especiales que pueden pausar su ejecuci√≥n, luego volver al punto donde se quedaron, recordando su scope y seguir retornando valores.

> Estos se utilizan para guardar la totalidad de datos infinitos, a trav√©s de una funci√≥n matem√°tica a valores futuros. De esta manera ocupan poca memoria, con respecto a si creamos un array u objeto.

### ‚öì C√≥mo utilizar generadores
> La sintaxis de los generadores comprende lo siguiente:

- La palabra reservada `function*` (con el asterisco al final).
- La palabra reservada `yield` que hace referencia al valor retornado cada vez que se invoque, recordando el valor anterior.
- Crear una variable a partir de la funci√≥n generadora.
- El m√©todo `next` devuelve un objeto que contiene una propiedad `value` con cada valor de `yield`; y otra propiedad `done` con el valor `true` o `false` si el generador ha terminado.

> Si el generador se lo invoca y ha retornado todos sus valores de `yield`, entonces devolver√° el objeto con las propiedades `value` con `undefined` y un `done` con `true`.

```
// Declaraci√≥n

üë®‚Äçüîß function* nombre(par√°metros){
    yield (primer valor retornado)
    yield (segundo valor retornado)
    ...
    yield (√∫ltimo valor retornado)

}

//Crear el generador
‚öì const generador = nombre(argumentos)

// Invocacioens

‚úÖ generador.next().value //primer valor retornado
‚úÖ generador.next().value //segundo valor retornado
...
‚úÖ generador.next().value //√∫ltimo valor retornado
```
### ‚öì Ejemplo de un generador
> Creamos un generador que retornara tres valores.

```
üë®‚Äçüîß function* generator(){
    yield 1
    yield 2
    yield 3
}

‚öì const generador = generator()

‚úÖ generador.next().value //1
‚úÖ generador.next().value //2
‚úÖ generador.next().value //3
‚úÖ generador.next() // {value: undefined, done: true}
```

### ‚öì Ejemplo utilizando for.
```
üë®‚Äçüîß function* iterate(array){
    for(let value of array){
        yield value;
    }
}

‚öì const it = iterate(['Alejo','Manuel','Nicolas','Camilo'])

// Invocaciones

üë®‚Äçüíª console.log(it.next().value) // ‚úÖ Alejo
üë®‚Äçüíª console.log(it.next().value) // ‚úÖ Manuel
üë®‚Äçüíª console.log(it.next().value) // ‚úÖ Nicolas
```
## 1Ô∏è‚É£1Ô∏è‚É£ Set
> Set es una nueva estructura de datos para almacenar elementos √∫nicos, es decir, sin elementos repetidos.

### ‚öì Como manipular los Sets
> Para manipular estas estructuras de datos, existen los siguientes m√©todos:

- `add(value)`: a√±ade un nuevo valor.
- `delete(value)`: elimina un elemento que contiene el `Set`, retorna un booleano si exist√≠a o no el valor.
- `has(value)`: retorna un booleano si existe o no el valor dentro del `Set`.
- `celar(value)`: elimina todos los valores del `Set`.
- `size`: retorna la cantidad de elementos del `Set`.


```
\\ ‚öì Se define una instancia.

const list = new Set();

\\ Agregando elementos al elemento Set.

‚ûï list.add('item 1');
‚ûï list.add('item 2').add('item 3');

üë®‚Äçüíª console.log(list)
‚úÖ ---> Result: Set(3) { 'item 1', 'item 2', 'item 3' }
```

### Como quitar los elementos repetidos.
```
// Array con elementos repetidos.

üë®‚Äçüîß const array = [1, 1, 2, 2, 3, 4, 4, 5]

// Creando nuevo array

üë®‚Äçüîß const sinRepetidos = [... new Set(array)]

üë®‚Äçüíª console.log(sinRepetidos)
‚úÖ ---> Result: [ 1, 2, 3, 4, 5 ]
```
# ‚öô EcmaScript 7

## Exponential
> El operador de potenciaci√≥n (exponential operator) consiste en elevar una base a un exponente utilizando el doble asterisco `(**)`.

> `base ** exponente`

```
üë®‚Äçüîß const data = 3 ** 4;
üë®‚Äçüíª console.log(data);
‚úÖ ---> Result: 81 
```
## Includes
> El m√©todo `includes` determina si un array o string incluye un determinado elemento. Devuelve `true` o `false`, si existe o no respectivamente.

```
// Utilizando arrays.

üë®‚Äçüîß let numbers = [1, 3, 4, 6, 7, 8];
üë®‚Äçüíª console.log(numbers.includes(9));
‚úÖ ---> Result: false

üë®‚Äçüîß const list = ['Oscar','David','Ana'];
üë®‚Äçüíª console.log(list.includes('Oscar'));
‚úÖ ---> Result: true
```
### Include para objetos.
> En objetos tambi√©n existen formas para saber si existe una propiedad.

- La palabra reservada `in`.
- El metodo de objetos `hasOwnProperty`.
- El m√©todo `Object.hasOwn`, que recibe el objeto y la propiedad a evaluar.

```
üë®‚Äçüîß const letras = { a: 1, b: 2, c: 3 }

üë®‚Äçüíª "a" in letras 
‚úÖ ---> Result: true
üë®‚Äçüíª letras.hasOwnProperty("a") 
‚úÖ ---> Result: true
üë®‚Äçüíª Object.hasOwn(letras, "a") 
‚úÖ ---> Result: true
```
# ‚öô EcmaScript 8
## üîß Object-entries
> `Object.entries()` devuelve un array con las entries en forma `[propiedad, valor]` del objeto enviado como argumento.
```
üë®‚Äçüîß const countries = {MX: 'Mexico', CO: 'Colombia', CL: 'Chile', PE: 'Peru'};

üë®‚Äçüíª console.log(Object.entries(countries));
‚úÖ ---> Result ‚¨á: 
[
  [ 'MX', 'Mexico' ],
  [ 'CO', 'Colombia' ],
  [ 'CL', 'Chile' ],
  [ 'PE', 'Peru' ]
]
```
## üîß Object-values
> `Object.values()` devuelve un array con los valores de cada propiedad del objeto enviado como argumento.
```
üë®‚Äçüîß const countries = {MX: 'Mexico', CO: 'Colombia', CL: 'Chile', PE: 'Peru'};

üë®‚Äçüíª console.log(Object.values(countries));
‚úÖ ---> Result: [ 'Mexico', 'Colombia', 'Chile', 'Peru' ]
```
## üîß Object-keys
> `Object.keys()` devuelve un array con las propiedades `(keys)` del objeto enviado como argumento.
```
üë®‚Äçüîß const countries = {MX: 'Mexico', CO: 'Colombia', CL: 'Chile', PE: 'Peru'};

üë®‚Äçüíª console.log(Object.keys(countries));
‚úÖ ---> Result: [ 'MX', 'CO', 'CL', 'PE' ]
```
## ‚öì String padding
> El padding consiste en rellenar un `string` por el principio o por el final, con el car√°cter especificado, repetido hasta que complete la longitud m√°xima.

> Este m√©todo recibe dos argumentos:

- La longitud m√°xima a rellenar, incluyendo el `string` inicial.
- El `string` para rellenar, por defecto, es un espacio.

> Si la longitud a rellenar es menor que la longitud del string actual, entonces no agregar√° nada.

### üõ† Metodos
#### üîß Metodo padStart
> El m√©todo `padStart` completa un `string` con otro `string` en el inicio hasta tener un total de caracteres especificado.
```
üë®‚Äçüîß const string = 'Hello';

üë®‚Äçüíª console.log(string.padStart(6,'_'));
‚úÖ ---> Result: _Hello

üë®‚Äçüíª console.log(string.padStart(10,'foo'));
‚úÖ ---> Result: foofoHello

üë®‚Äçüíª console.log(string.padStart(6,'123456'));
‚úÖ ---> Result: 123Hello
```
### üîß Metodo padEnd
> El m√©todo padEnd completa un string con otro string en el final hasta tener un total de caracteres especificado.
```
üë®‚Äçüîß const string = 'Hello';
üë®‚Äçüíª console.log(string.padEnd(8,'123456'));
‚úÖ ---> Result: Hello123

üë®‚Äçüíª console.log(string.padEnd(10,'123456'));
‚úÖ ---> Result: Hello12345

üë®‚Äçüíª console.log(string.padEnd(6,'123456'));
‚úÖ ---> Result: Hello1
```
## ‚öì Trailing commas
> Las trailing commas consisten en comas al final de objetos o arrays que faciliten a√±adir nuevos elementos y evitar errores de sintaxis.
```
üë®‚Äçüîß const array = [24,34,25,26,,,,45]; //üì¢ Trailing commas

üë®‚Äçüíª console.log(array);
‚úÖ ---> Result: [ 24, 34, 25, 26, <3 empty items>, 45 ]
üë®‚Äçüíª console.log(array.length);
‚úÖ ---> Result: 8
```

## ‚öì Funciones as√≠ncronas
> Es otra forma de ejecutar funciones, pero esta presente una particularidad, ya que se ejecutara la funcion pero al utilizar `await` en una proemsa la funcion que tiene el `async` estara pendiente de la respuesta que le devuelva.

### Como utilizar funciones as√≠ncronas
> La funci√≥n as√≠ncrona se crea mediante la palabra reservada `async` y retorna una promesa.
```
üë®‚Äçüîß async function asyncFunction () {...}

üë®‚Äçüîß const asyncFunction = async () => { ... } 
```
> La palabra reservada await significa que espera hasta que una promesa sea resuelta y solo funciona dentro de una funci√≥n as√≠ncrona. Los bloques try / catch sirven para manejar si la promesa ha sido resuelta o rechazada.

```
üë®‚Äçüîß async function asyncFunction () {
  try {
    const response = await promesa()
    return response
  } catch (error) {
    return error
  }
}
```
> ¬øCu√°l es la mejor forma de manejar promesas, then o async / await? Ambas son muy √∫tiles, manejar ambas te har√° un mejor desarrollador.

### üë®‚Äçüíª Ejemplo Async-Await
```
üë®‚Äçüîß const fnAsync = () => {
    return new Promise((resolve, reject) => {
        (true) 
            ? setTimeout(() => resolve('AsynC'),2000) 
            : reject(new Error('Error!'));
    });
}

üë®‚Äçüîß const anotherFn = async () => {
 ‚è≥ const somethig = await fnAsync();
    console.log(somethig);
    console.log('Hello!');
}

üë®‚Äçüíª anotherFn();
‚úÖ ---> Result: AsynC Hello!
```